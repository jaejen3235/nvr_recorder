// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RpType.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_RpType_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_RpType_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RpType_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_RpType_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_RpType_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace Rp {

enum ImageFormat : int {
  IMAGE_FORMAT_YUV420 = 0,
  IMAGE_FORMAT_RGB32 = 1,
  IMAGE_FORMAT_RGB565 = 2,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageFormat_IsValid(int value);
constexpr ImageFormat ImageFormat_MIN = IMAGE_FORMAT_YUV420;
constexpr ImageFormat ImageFormat_MAX = IMAGE_FORMAT_RGB565;
constexpr int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFormat_descriptor();
template<typename T>
inline const std::string& ImageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFormat_descriptor(), enum_t_value);
}
inline bool ImageFormat_Parse(
    const std::string& name, ImageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum AddressType : int {
  ADDRESS_TYPE_IPV4 = 0,
  ADDRESS_TYPE_FEN = 1,
  AddressType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AddressType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AddressType_IsValid(int value);
constexpr AddressType AddressType_MIN = ADDRESS_TYPE_IPV4;
constexpr AddressType AddressType_MAX = ADDRESS_TYPE_FEN;
constexpr int AddressType_ARRAYSIZE = AddressType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddressType_descriptor();
template<typename T>
inline const std::string& AddressType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddressType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddressType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddressType_descriptor(), enum_t_value);
}
inline bool AddressType_Parse(
    const std::string& name, AddressType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddressType>(
    AddressType_descriptor(), name, value);
}
enum DeviceType : int {
  DEVICE_TYPE_DVR = 0,
  DEVICE_TYPE_VIDEO_ENCODER = 1,
  DEVICE_TYPE_IP_CAMERA = 3,
  DEVICE_TYPE_HYBRIDDVR = 6,
  DEVICE_TYPE_NVR = 7,
  DEVICE_TYPE_UNKNOWN = 999,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = DEVICE_TYPE_DVR;
constexpr DeviceType DeviceType_MAX = DEVICE_TYPE_UNKNOWN;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceType_descriptor();
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceType_descriptor(), enum_t_value);
}
inline bool DeviceType_Parse(
    const std::string& name, DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum CameraState : int {
  CAMERA_STATE_UNKNOWN = 0,
  CAMERA_STATE_ACTIVE = 1,
  CAMERA_STATE_INACTIVE = 11,
  CAMERA_STATE_VIDEO_LOSS = 12,
  CAMERA_STATE_NONE = 13,
  CAMERA_STATE_NOT_CONNECTED = 14,
  CAMERA_STATE_COVERT1 = 21,
  CAMERA_STATE_COVERT2 = 22,
  CAMERA_STATE_SEARCH = 101,
  CameraState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraState_IsValid(int value);
constexpr CameraState CameraState_MIN = CAMERA_STATE_UNKNOWN;
constexpr CameraState CameraState_MAX = CAMERA_STATE_SEARCH;
constexpr int CameraState_ARRAYSIZE = CameraState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraState_descriptor();
template<typename T>
inline const std::string& CameraState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraState_descriptor(), enum_t_value);
}
inline bool CameraState_Parse(
    const std::string& name, CameraState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraState>(
    CameraState_descriptor(), name, value);
}
enum PtzFunction : int {
  PTZ_FUNCTION_NONE = 0,
  PTZ_FUNCTION_PAN_TILT = 1,
  PTZ_FUNCTION_ZOOM = 2,
  PTZ_FUNCTION_FOCUS = 4,
  PTZ_FUNCTION_IRIS = 8,
  PTZ_FUNCTION_PRESET_SETUP = 16,
  PTZ_FUNCTION_PRESET_MOVE = 32,
  PTZ_FUNCTION_OSD_MENU = 64,
  PTZ_FUNCTION_FOCUS_ONEPUSH = 256,
  PtzFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PtzFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PtzFunction_IsValid(int value);
constexpr PtzFunction PtzFunction_MIN = PTZ_FUNCTION_NONE;
constexpr PtzFunction PtzFunction_MAX = PTZ_FUNCTION_FOCUS_ONEPUSH;
constexpr int PtzFunction_ARRAYSIZE = PtzFunction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PtzFunction_descriptor();
template<typename T>
inline const std::string& PtzFunction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PtzFunction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PtzFunction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PtzFunction_descriptor(), enum_t_value);
}
inline bool PtzFunction_Parse(
    const std::string& name, PtzFunction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PtzFunction>(
    PtzFunction_descriptor(), name, value);
}
enum PtzCommand : int {
  PTZ_COMMAND_MOVE_N = 0,
  PTZ_COMMAND_MOVE_NE = 1,
  PTZ_COMMAND_MOVE_E = 2,
  PTZ_COMMAND_MOVE_SE = 3,
  PTZ_COMMAND_MOVE_S = 4,
  PTZ_COMMAND_MOVE_SW = 5,
  PTZ_COMMAND_MOVE_W = 6,
  PTZ_COMMAND_MOVE_NW = 7,
  PTZ_COMMAND_ZOOM_OUT = 8,
  PTZ_COMMAND_ZOOM_IN = 9,
  PTZ_COMMAND_FOCUS_NEAR = 10,
  PTZ_COMMAND_FOCUS_FAR = 11,
  PTZ_COMMAND_IRIS_CLOSE = 12,
  PTZ_COMMAND_IRIS_OPEN = 13,
  PTZ_COMMAND_PRESET_MOVE = 14,
  PTZ_COMMAND_STOP_MOVE = 16,
  PTZ_COMMAND_STOP_ZOOM = 17,
  PTZ_COMMAND_STOP_FOCUS = 18,
  PTZ_COMMAND_STOP_IRIS = 19,
  PTZ_COMMAND_FOCUS_ONEPUSH = 52,
  PTZ_COMMAND_LENS_RESET = 69,
  PtzCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PtzCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PtzCommand_IsValid(int value);
constexpr PtzCommand PtzCommand_MIN = PTZ_COMMAND_MOVE_N;
constexpr PtzCommand PtzCommand_MAX = PTZ_COMMAND_LENS_RESET;
constexpr int PtzCommand_ARRAYSIZE = PtzCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PtzCommand_descriptor();
template<typename T>
inline const std::string& PtzCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PtzCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PtzCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PtzCommand_descriptor(), enum_t_value);
}
inline bool PtzCommand_Parse(
    const std::string& name, PtzCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PtzCommand>(
    PtzCommand_descriptor(), name, value);
}
enum PtzCommandMethod : int {
  PTZ_COMMAND_METHOD_STEP = 0,
  PTZ_COMMAND_METHOD_CONTINUOUS = 1,
  PtzCommandMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PtzCommandMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PtzCommandMethod_IsValid(int value);
constexpr PtzCommandMethod PtzCommandMethod_MIN = PTZ_COMMAND_METHOD_STEP;
constexpr PtzCommandMethod PtzCommandMethod_MAX = PTZ_COMMAND_METHOD_CONTINUOUS;
constexpr int PtzCommandMethod_ARRAYSIZE = PtzCommandMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PtzCommandMethod_descriptor();
template<typename T>
inline const std::string& PtzCommandMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PtzCommandMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PtzCommandMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PtzCommandMethod_descriptor(), enum_t_value);
}
inline bool PtzCommandMethod_Parse(
    const std::string& name, PtzCommandMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PtzCommandMethod>(
    PtzCommandMethod_descriptor(), name, value);
}
enum OsdInfoType : int {
  OSD_INFO_TYPE_NONE = 0,
  OSD_INFO_TYPE_LENS_RESET = 1,
  OSD_INFO_TYPE_FOCUS_RESET = 2,
  OSD_INFO_TYPE_PTZ_RESET = 3,
  OSD_INFO_TYPE_AUTO_FOCUS = 10,
  OsdInfoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OsdInfoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OsdInfoType_IsValid(int value);
constexpr OsdInfoType OsdInfoType_MIN = OSD_INFO_TYPE_NONE;
constexpr OsdInfoType OsdInfoType_MAX = OSD_INFO_TYPE_AUTO_FOCUS;
constexpr int OsdInfoType_ARRAYSIZE = OsdInfoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OsdInfoType_descriptor();
template<typename T>
inline const std::string& OsdInfoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OsdInfoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OsdInfoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OsdInfoType_descriptor(), enum_t_value);
}
inline bool OsdInfoType_Parse(
    const std::string& name, OsdInfoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OsdInfoType>(
    OsdInfoType_descriptor(), name, value);
}
enum RewindCommand : int {
  REWIND_COMMAND_DUMMY = 0,
  REWIND_COMMAND_FAST = -3,
  REWIND_COMMAND_FASTER = -4,
  REWIND_COMMAND_FASTEST = -5,
  RewindCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RewindCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RewindCommand_IsValid(int value);
constexpr RewindCommand RewindCommand_MIN = REWIND_COMMAND_FASTEST;
constexpr RewindCommand RewindCommand_MAX = REWIND_COMMAND_DUMMY;
constexpr int RewindCommand_ARRAYSIZE = RewindCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewindCommand_descriptor();
template<typename T>
inline const std::string& RewindCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewindCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewindCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RewindCommand_descriptor(), enum_t_value);
}
inline bool RewindCommand_Parse(
    const std::string& name, RewindCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RewindCommand>(
    RewindCommand_descriptor(), name, value);
}
enum FastForwardCommand : int {
  FAST_FORWARD_COMMAND_DUMMY = 0,
  FAST_FORWARD_COMMAND_FAST = 3,
  FAST_FORWARD_COMMAND_FASTER = 4,
  FAST_FORWARD_COMMAND_FASTEST = 5,
  FastForwardCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FastForwardCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FastForwardCommand_IsValid(int value);
constexpr FastForwardCommand FastForwardCommand_MIN = FAST_FORWARD_COMMAND_DUMMY;
constexpr FastForwardCommand FastForwardCommand_MAX = FAST_FORWARD_COMMAND_FASTEST;
constexpr int FastForwardCommand_ARRAYSIZE = FastForwardCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FastForwardCommand_descriptor();
template<typename T>
inline const std::string& FastForwardCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FastForwardCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FastForwardCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FastForwardCommand_descriptor(), enum_t_value);
}
inline bool FastForwardCommand_Parse(
    const std::string& name, FastForwardCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FastForwardCommand>(
    FastForwardCommand_descriptor(), name, value);
}
enum PlayCommand : int {
  PLAY_COMAND_DUMMY = 0,
  PLAY_COMMAND_BACK_FASTEST = -5,
  PLAY_COMMAND_BACK_FASTER = -4,
  PLAY_COMMAND_BACK_FAST = -3,
  PLAY_COMMAND_PLAY_FAST = 3,
  PLAY_COMMAND_PLAY_FASTER = 4,
  PLAY_COMMAND_PLAY_FASTEST = 5,
  PlayCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayCommand_IsValid(int value);
constexpr PlayCommand PlayCommand_MIN = PLAY_COMMAND_BACK_FASTEST;
constexpr PlayCommand PlayCommand_MAX = PLAY_COMMAND_PLAY_FASTEST;
constexpr int PlayCommand_ARRAYSIZE = PlayCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayCommand_descriptor();
template<typename T>
inline const std::string& PlayCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayCommand_descriptor(), enum_t_value);
}
inline bool PlayCommand_Parse(
    const std::string& name, PlayCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayCommand>(
    PlayCommand_descriptor(), name, value);
}
enum SelfGuardCommand : int {
  SELF_GUARD_COMMAND_START = 0,
  SELF_GUARD_COMMAND_STOP = 1,
  SELF_GUARD_COMMAND_QUERY_STATUS = 4,
  SELF_GUARD_COMMAND_FORCED_START = 5,
  SelfGuardCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SelfGuardCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SelfGuardCommand_IsValid(int value);
constexpr SelfGuardCommand SelfGuardCommand_MIN = SELF_GUARD_COMMAND_START;
constexpr SelfGuardCommand SelfGuardCommand_MAX = SELF_GUARD_COMMAND_FORCED_START;
constexpr int SelfGuardCommand_ARRAYSIZE = SelfGuardCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfGuardCommand_descriptor();
template<typename T>
inline const std::string& SelfGuardCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelfGuardCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelfGuardCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelfGuardCommand_descriptor(), enum_t_value);
}
inline bool SelfGuardCommand_Parse(
    const std::string& name, SelfGuardCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelfGuardCommand>(
    SelfGuardCommand_descriptor(), name, value);
}
enum SelfGuardResult : int {
  SELF_GUARD_RESULT_FAIL_UNKNOWN = 0,
  SELF_GUARD_RESULT_SUCCESS = 1,
  SELF_GUARD_RESULT_FAIL_NO_AUTHORITY = 2,
  SELF_GUARD_RESULT_FAIL_UNSUPPORTED = 3,
  SELF_GUARD_RESULT_FAIL_DOOR_NOT_CLOSED = 4,
  SelfGuardResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SelfGuardResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SelfGuardResult_IsValid(int value);
constexpr SelfGuardResult SelfGuardResult_MIN = SELF_GUARD_RESULT_FAIL_UNKNOWN;
constexpr SelfGuardResult SelfGuardResult_MAX = SELF_GUARD_RESULT_FAIL_DOOR_NOT_CLOSED;
constexpr int SelfGuardResult_ARRAYSIZE = SelfGuardResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfGuardResult_descriptor();
template<typename T>
inline const std::string& SelfGuardResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelfGuardResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelfGuardResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelfGuardResult_descriptor(), enum_t_value);
}
inline bool SelfGuardResult_Parse(
    const std::string& name, SelfGuardResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelfGuardResult>(
    SelfGuardResult_descriptor(), name, value);
}
enum SelfGuardStatus : int {
  SELF_GUARD_STATUS_UNKNOWN = 0,
  SELF_GUARD_STATUS_GUARD_ON = 1,
  SELF_GUARD_STATUS_GUARD_OFF = 2,
  SelfGuardStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SelfGuardStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SelfGuardStatus_IsValid(int value);
constexpr SelfGuardStatus SelfGuardStatus_MIN = SELF_GUARD_STATUS_UNKNOWN;
constexpr SelfGuardStatus SelfGuardStatus_MAX = SELF_GUARD_STATUS_GUARD_OFF;
constexpr int SelfGuardStatus_ARRAYSIZE = SelfGuardStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelfGuardStatus_descriptor();
template<typename T>
inline const std::string& SelfGuardStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelfGuardStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelfGuardStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelfGuardStatus_descriptor(), enum_t_value);
}
inline bool SelfGuardStatus_Parse(
    const std::string& name, SelfGuardStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelfGuardStatus>(
    SelfGuardStatus_descriptor(), name, value);
}
enum DisconnectReason : int {
  DISCONNECT_REASON_UNKNOWN = 0,
  DISCONNECT_REASON_LOGOUT = 1,
  DISCONNECT_REASON_FULL_CHANNEL = 2,
  DISCONNECT_REASON_INVALID_VERSION = 3,
  DISCONNECT_REASON_LOGIN_FAIL = 4,
  DISCONNECT_REASON_ADMIN_CLOSE = 5,
  DISCONNECT_REASON_ADMIN_TIMEOUT = 6,
  DISCONNECT_REASON_SYS_SHUTDOWN = 7,
  DISCONNECT_REASON_NO_CHANNEL = 8,
  DISCONNECT_REASON_NO_SERVER = 10,
  DISCONNECT_REASON_NET_DOWN = 11,
  DISCONNECT_REASON_NET_UNREACHABLE = 12,
  DISCONNECT_REASON_CONN_TIMEOUT = 13,
  DISCONNECT_REASON_CONN_RESET = 14,
  DISCONNECT_REASON_HOST_DOWN = 15,
  DISCONNECT_REASON_HOST_UNREACHABLE = 16,
  DISCONNECT_REASON_CONN_ABORTED = 17,
  DISCONNECT_REASON_CONN_CANCEL = 20,
  DISCONNECT_REASON_NET_NORESPONSE = 21,
  DISCONNECT_REASON_NET_NOISY = 22,
  DISCONNECT_REASON_SEND_OVERFLOW = 23,
  DISCONNECT_REASON_INVALID_OEM = 24,
  DISCONNECT_REASON_NO_AUTHORITY = 25,
  DISCONNECT_REASON_PORT_USED = 26,
  DISCONNECT_REASON_SSL_CONNECTION_FAILED = 27,
  DISCONNECT_REASON_NET_TIMEOUT = 28,
  DISCONNECT_REASON_HOST_TIMEOUT = 29,
  DISCONNECT_REASON_NOT_SUPPORT_RTP_TCP = 30,
  DISCONNECT_REASON_SOCKET_ERROR_OCCURRED = 31,
  DISCONNECT_REASON_FEN_RENDEZ_CONN_FAILED = 1000,
  DISCONNECT_REASON_FEN_RENDEZ_NO_ELEMENT = 1001,
  DISCONNECT_REASON_FEN_RELAY_CONN_FAILED = 1002,
  DISCONNECT_REASON_FEN_RELAY_NOT_AVAILABLE = 1003,
  DISCONNECT_REASON_FEN_DIRECT_CONN_DOWN = 1004,
  DISCONNECT_REASON_FEN_UDT_CONN_DOWN = 1005,
  DISCONNECT_REASON_FEN_RELAY_CONN_DOWN = 1006,
  DISCONNECT_REASON_SERVER_SESSION_TIMEOUT = 1010,
  DISCONNECT_REASON_NOT_ACCEPTABLE_AT_THIS_TIME = 1011,
  DISCONNECT_REASON_REPETITIVE_CONNECTION = 1012,
  DISCONNECT_REASON_PASSWORD_RESET_REQUIRED = 1013,
  DISCONNECT_REASON_PASSWORD_RESET_AUTH_FAILED = 1020,
  DISCONNECT_REASON_PASSWORD_RESET_PERSONAL_INFO_NOT_FOUND = 1021,
  DISCONNECT_REASON_LOGGED_IN_FROM_OTHER_DEVICE = 1030,
  DISCONNECT_REASON_OPERATION_FROM_NOT_ALLOWED_HOST = 1031,
  DISCONNECT_REASON_CONNECTIVITY_CHECK_FINISHED = 1040,
  DISCONNECT_REASON_TWO_FA_FUNCTION_CANCELED = 1050,
  DISCONNECT_REASON_SSL_REQUIRED_OPERATION = 1067,
  DISCONNECT_REASON_DIP2_SFO_ENABLED = 1068,
  DISCONNECT_REASON_INVALID_RECEIVE_PACKET_BUFFER = 1100,
  DISCONNECT_REASON_INVALID_SEND_PACKET_BUFFER = 1101,
  DISCONNECT_REASON_ALIVE_CHECK_TICKOUT = 1102,
  DISCONNECT_REASON_RTSP_START_FAILED = 2001,
  DISCONNECT_REASON_RTSP_STOP_FAILED = 2002,
  DISCONNECT_REASON_RTSP_IMAGE_NOT_RECEIVED = 2003,
  DISCONNECT_REASON_RTSP_TEARDOWN_DISCONNECT = 2004,
  DISCONNECT_REASON_RTSP_TUNNELING_DISCONNECT = 2005,
  DISCONNECT_REASON_RTSP_SESSION_ALREADY_FINISHED = 2006,
  DISCONNECT_REASON_RTSP_ALIVE_CHECK_ERROR = 2007,
  DISCONNECT_REASON_RTSP_OVER_ALIVE_CHECK_INTERVAL = 2008,
  DISCONNECT_REASON_AUTO_LOGOUT = 50000,
  DISCONNECT_REASON_UNSUPPORT_R2 = 50001,
  DISCONNECT_REASON_LOGIN_FAIL_PASSWORD_TIMES_FMT = 50008,
  DISCONNECT_REASON_EXCEEDED_MAX_CONNECT_COUNT = 50010,
  DisconnectReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DisconnectReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DisconnectReason_IsValid(int value);
constexpr DisconnectReason DisconnectReason_MIN = DISCONNECT_REASON_UNKNOWN;
constexpr DisconnectReason DisconnectReason_MAX = DISCONNECT_REASON_EXCEEDED_MAX_CONNECT_COUNT;
constexpr int DisconnectReason_ARRAYSIZE = DisconnectReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisconnectReason_descriptor();
template<typename T>
inline const std::string& DisconnectReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisconnectReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisconnectReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DisconnectReason_descriptor(), enum_t_value);
}
inline bool DisconnectReason_Parse(
    const std::string& name, DisconnectReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DisconnectReason>(
    DisconnectReason_descriptor(), name, value);
}
enum RequestResultSuccess : int {
  REQUEST_RESULT_SUCCESS = 0,
  RequestResultSuccess_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestResultSuccess_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestResultSuccess_IsValid(int value);
constexpr RequestResultSuccess RequestResultSuccess_MIN = REQUEST_RESULT_SUCCESS;
constexpr RequestResultSuccess RequestResultSuccess_MAX = REQUEST_RESULT_SUCCESS;
constexpr int RequestResultSuccess_ARRAYSIZE = RequestResultSuccess_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestResultSuccess_descriptor();
template<typename T>
inline const std::string& RequestResultSuccess_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestResultSuccess>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestResultSuccess_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestResultSuccess_descriptor(), enum_t_value);
}
inline bool RequestResultSuccess_Parse(
    const std::string& name, RequestResultSuccess* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestResultSuccess>(
    RequestResultSuccess_descriptor(), name, value);
}
enum RequestResultFail : int {
  REQUEST_RESULT_FAIL = 0,
  RequestResultFail_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestResultFail_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestResultFail_IsValid(int value);
constexpr RequestResultFail RequestResultFail_MIN = REQUEST_RESULT_FAIL;
constexpr RequestResultFail RequestResultFail_MAX = REQUEST_RESULT_FAIL;
constexpr int RequestResultFail_ARRAYSIZE = RequestResultFail_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestResultFail_descriptor();
template<typename T>
inline const std::string& RequestResultFail_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestResultFail>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestResultFail_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestResultFail_descriptor(), enum_t_value);
}
inline bool RequestResultFail_Parse(
    const std::string& name, RequestResultFail* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestResultFail>(
    RequestResultFail_descriptor(), name, value);
}
enum REvent : int {
  REVENT_NONE = 0,
  REVENT_SYSTEM = 9999,
  REVENT_ALARM_IN_ON = 1,
  REVENT_ALARM_IN_OFF = 2,
  REVENT_ALARM_IN_BAD_ON = 3,
  REVENT_ALARM_IN_BAD_OFF = 4,
  REVENT_USER_DEFINED_ALARM_ON = 5,
  REVENT_ALARM_OUT_ON = 10,
  REVENT_MOTION_ON = 100,
  REVENT_MOTION_OFF = 101,
  REVENT_TRIPZONE_ON = 104,
  REVENT_TRIPZONE_OFF = 105,
  REVENT_VIDEO_ANALYTICS_ON = 120,
  REVENT_VIDEO_ANALYTICS_OFF = 121,
  REVENT_IGNORED_MOTION_ON = 122,
  REVENT_IGNORED_TRIPZONE_ON = 123,
  REVENT_OBJECT_DETECTION_ON = 102,
  REVENT_OBJECT_DETECTION_OFF = 103,
  REVENT_IGNORED_OBJECT_DETECTION_ON = 124,
  REVENT_VIDEO_INIT = 200,
  REVENT_VIDEO_LOSS_ON = 201,
  REVENT_VIDEO_LOSS_OFF = 202,
  REVENT_VIDEO_BLIND_ON = 203,
  REVENT_VIDEO_BLIND_OFF = 204,
  REVENT_TAMPER_ON = 205,
  REVENT_TAMPER_OFF = 206,
  REVENT_TAMPERING_SWITCH_ON = 207,
  REVENT_TAMPERING_SWITCH_OFF = 208,
  REVENT_TEXT_IN_ON = 300,
  REVENT_TEXT_IN_OFF = 301,
  REVENT_TEXT_IN_DATA = 302,
  REVENT_TEXT_IN_BAD_ON = 303,
  REVENT_TEXT_IN_BAD_OFF = 304,
  REVENT_FACE_DETECTION_ON = 400,
  REVENT_FACE_DETECTION_OFF = 401,
  REVENT_IGNORED_FACE_DETECTION_ON = 402,
  REVENT_DAY_ON = 500,
  REVENT_NIGHT_ON = 501,
  REVENT_PIR_ON = 600,
  REVENT_PIR_OFF = 601,
  REVENT_IGNORED_PIR_ON = 602,
  REVENT_AUTO_TRACKING_ON = 700,
  REVENT_AUTO_TRACKING_OFF = 701,
  REVENT_TANGO_FULL_ON = 100000,
  REVENT_TANGO_FULL_OFF = 100001,
  REVENT_TANGO_ALMOST_FULL_ON = 100002,
  REVENT_TANGO_ALMOST_FULL_OFF = 100003,
  REVENT_TANGO_PARTIALLY_FULL_ON = 100004,
  REVENT_TANGO_PARTIALLY_FULL_OFF = 100005,
  REVENT_TANGO_PARTIALLY_ALMOST_FULL_ON = 100006,
  REVENT_TANGO_PARTIALLY_ALMOST_FULL_OFF = 100007,
  REVENT_DISK_BAD = 200000,
  REVENT_DISK_TEMPERATURE_ON = 200001,
  REVENT_DISK_TEMPERATURE_OFF = 200002,
  REVENT_DISK_SMART_ON = 200003,
  REVENT_DISK_SMART_OFF = 200004,
  REVENT_DISK_CONFIG_CHANGE = 200005,
  REVENT_DISK_ON = 200006,
  REVENT_DISK_OFF = 200007,
  REVENT_NO_DISK = 200008,
  REVENT_RAID_BROKEN_ON = 200009,
  REVENT_RAID_BROKEN_OFF = 200010,
  REVENT_RAID_DEGRADE_ON = 200011,
  REVENT_RAID_DEGRADE_OFF = 200012,
  REVENT_RECORD_STORAGE_NOT_FOUND_OFF = 200013,
  REVENT_SYSTEM_ALIVE = 300000,
  REVENT_PANIC_ON = 300001,
  REVENT_PANIC_OFF = 300002,
  REVENT_FAN_ERROR_ON = 300003,
  REVENT_FAN_ERROR_OFF = 300004,
  REVENT_SYSTEM_BOOT_UP = 300005,
  REVENT_SYSTEM_RESTART = 300006,
  REVENT_SYSTEM_SHUTDOWN = 300007,
  REVENT_COVER_OPEN = 300008,
  REVENT_COVER_CLOSE = 300009,
  REVENT_STOP_RECORD_ON = 300010,
  REVENT_LOGIN_FAILED_SEVERAL_TIMES = 300011,
  REVENT_USER_LOGIN = 300012,
  REVENT_USER_LOGOUT = 300013,
  REVENT_SETUP_CHANGED = 300014,
  REVENT_ONLINE_UPGRADE_FOUND = 300016,
  REVENT_ONLINE_UPGRADE_SUCCEEDED = 300017,
  REVENT_ONLINE_UPGRADE_FAILED = 300018,
  REVENT_REDUNDANT_POWER_FAILURE_ON = 300019,
  REVENT_REDUNDANT_POWER_FAILURE_OFF = 300020,
  REVENT_LOG_ALMOST_FULL = 300021,
  REVENT_BATTERY_LOW = 300022,
  REVENT_SYSTEM_LOG_ON = 300023,
  REVENT_LOGIN_FAILED_SEVERAL_TIMES_OFF = 300024,
  REVENT_RECORDER_BAD_ON = 400000,
  REVENT_RECORDER_BAD_OFF = 400001,
  REVENT_INSTANT_RECORDING_ON = 400002,
  REVENT_INSTANT_RECORDING_OFF = 400003,
  REVENT_CAMERA_RECORD_BAD_ON = 400004,
  REVENT_CAMERA_RECORD_BAD_OFF = 400005,
  REVENT_AUDIO_ON = 500000,
  REVENT_AUDIO_OFF = 500001,
  REVENT_IGNORED_AUDIO_ON = 500002,
  REVENT_CAMERA_FAN_ERROR_ON = 700000,
  REVENT_CAMERA_FAN_ERROR_OFF = 700001,
  REVENT_VA_PEOPLE_COUNT_SETUP_CHANGED = 800000,
  REVENT_VA_PEOPLE_COUNT_IN = 800001,
  REVENT_VA_PEOPLE_COUNT_OUT = 800002,
  REVENT_VA_QUEUE_MAX_OBJECT_EXCEED_ON = 800003,
  REVENT_VA_QUEUE_MAX_OBJECT_EXCEED_OFF = 800004,
  REVENT_VA_QUEUE_MAX_WAIT_TIME_EXCEED_ON = 800005,
  REVENT_VA_QUEUE_MAX_WAIT_TIME_EXCEED_OFF = 800006,
  REVENT_VA_INIT = 800007,
  REVENT_VA_LOSS_ON = 800008,
  REVENT_VA_LOSS_OFF = 800009,
  REVENT_VA_INTRUSION_ON = 800010,
  REVENT_VA_INTRUSION_OFF = 800011,
  REVENT_VA_IGNORED_INTRUSION_ON = 800012,
  REVENT_VA_LOITERING_ON = 800013,
  REVENT_VA_LOITERING_OFF = 800014,
  REVENT_VA_IGNORED_LOITERING_ON = 800015,
  REVENT_VA_LINE_CROSSING_ON = 800016,
  REVENT_VA_LINE_CROSSING_OFF = 800017,
  REVENT_VA_IGNORED_LINE_CROSSING_ON = 800018,
  REVENT_VA_FALL_DETECTION_ON = 800022,
  REVENT_VA_FALL_DETECTION_OFF = 800023,
  REVENT_VA_IGNORED_FALL_DETECTION_ON = 800024,
  REVENT_VA_EXCEED_OCCUPANCY_LIMIT_ON = 800025,
  REVENT_VA_EXCEED_OCCUPANCY_LIMIT_OFF = 800026,
  REVENT_VA_CROWD_DETECTION_ON = 800027,
  REVENT_VA_CROWD_DETECTION_OFF = 800028,
  REVENT_VA_SOCIAL_DISTANCING_VIOLATION_ON = 800029,
  REVENT_VA_SOCIAL_DISTANCING_VIOLATION_OFF = 800030,
  REVENT_VA_IGNORED_SOCIAL_DISTANCING_VIOLATION_ON = 800031,
  REVENT_VA_MASK_RULE_VIOLATION_ON = 800032,
  REVENT_VA_MASK_RULE_VIOLATION_OFF = 800033,
  REVENT_VA_IGNORED_MASK_RULE_VIOLATION_ON = 800034,
  REVENT_VA_QUEUE_CONGESTION_LEVEL_HIGH_ON = 800035,
  REVENT_VA_QUEUE_CONGESTION_LEVEL_HIGH_OFF = 800036,
  REVENT_VA_ABANDONED_OBJECT_DETECTION_ON = 800037,
  REVENT_VA_ABANDONED_OBJECT_DETECTION_OFF = 800038,
  REVENT_VA_VIOLENCE_DETECTION_ON = 800039,
  REVENT_VA_VIOLENCE_DETECTION_OFF = 800040,
  REVENT_VA_REMOVED_OBJECT_DETECTION_ON = 800041,
  REVENT_VA_REMOVED_OBJECT_DETECTION_OFF = 800042,
  REVENT_VA_FIRE_DETECTION_ON = 800043,
  REVENT_VA_FIRE_DETECTION_OFF = 800044,
  REVENT_VA_IGNORED_FIRE_DETECTION_ON = 800045,
  REVENT_VA_EXPLOSION_DETECTION_ON = 800046,
  REVENT_VA_EXPLOSION_DETECTION_OFF = 800047,
  REVENT_VA_IGNORED_EXPLOSION_DETECTION_ON = 800048,
  REVENT_VA_ROCKFALL_DETECTION_ON = 800049,
  REVENT_VA_ROCKFALL_DETECTION_OFF = 800050,
  REVENT_VA_IGNORED_ROCKFALL_DETECTION_ON = 800051,
  REVENT_VA_IGNORED_VIOLENCE_DETECTION_ON = 800052,
  REVENT_ANPR_ON = 810001,
  REVENT_ANPR_OFF = 810002,
  REVENT_ANPR_BLACK_LIST_ON = 810003,
  REVENT_ANPR_BLACK_LIST_OFF = 810004,
  REVENT_ANPR_WHITE_LIST_ON = 810005,
  REVENT_ANPR_WHITE_LIST_OFF = 810006,
  REVENT_ALARMBOX_INIT = 900000,
  REVENT_ALARMBOX_LOSS_ON = 900001,
  REVENT_ALARMBOX_LOSS_OFF = 900002,
  REVENT_NETWORK_ALARM_ON = 1000000,
  REVENT_NETWORK_ALARM_OFF = 1000001,
  REVENT_NETWORK_CAMERA_CONNECTED = 1000010,
  REVENT_NETWORK_CAMERA_DISCONNECTED = 1000011,
  REVENT_NETWORK_FAILOVER_ON = 1000020,
  REVENT_NETWORK_FAILOVER_OFF = 1000021,
  REVENT_NFO_NVR_FAILURE_ON = 1001000,
  REVENT_NFO_NVR_FAILURE_OFF = 1001001,
  REVENT_NFO_FAILOVER_ON = 1001002,
  REVENT_NFO_FAILOVER_OFF = 1001003,
  REVENT_NFO_FAILBACK = 1001004,
  REVENT_NFO_REPLACE = 1001005,
  REVENT_INTERCOM_CALL = 1100000,
  REVENT_INTERCOM_CALL_DONE = 1100001,
  REVENT_INTERCOM_CALL_CANCEL = 1100002,
  REVENT_INTERCOM_CALL_TO_SERVER = 1100003,
  REVENT_INTERCOM_CALL_TO_SERVER_DONE = 1100004,
  REVENT_INTERCOM_CALL_TO_SERVER_CANCEL = 1100005,
  REVENT_INTERCOM_MISSED_CALL = 1100006,
  REVENT_CAR_OVERSPEED_ON = 1100000000,
  REVENT_CAR_OVERSPEED_OFF = 1100000001,
  REVENT_CAR_SUDDEN_ACCELERATION = 1100000002,
  REVENT_CAR_SUDDEN_STOP = 1100000003,
  REVENT_CAR_STARTING_WITH_DOORS_OPEN = 1100000004,
  REVENT_GPS_RECEIVE_ERROR_ON = 1100000100,
  REVENT_GPS_RECEIVE_ERROR_OFF = 1100000101,
  REVENT_SIPASS_RECORD_ON = 1200000000,
  REVENT_SIPASS_RECORD_OFF = 1200000001,
  REVENT_SECOM_SMART_LOOP = 1210000000,
  REVENT_SECOM_SMART_PANIC = 1210000001,
  REVENT_SECOM_SMART_CARD = 1210000002,
  REVENT_SECOM_SMART_MACHINE = 1210000003,
  REVENT_SPC_MOTION_XOR_TRIPZONE_ON = 1230000000,
  REVENT_SPC_MOTION_XOR_TRIPZONE_OFF = 1230000001,
  REVENT_NSOK_DOOR_LOCK = 1240000000,
  REVENT_NSOK_GUARD_ON = 1240000001,
  REVENT_NSOK_GUARD_OFF = 1240000002,
  REVENT_SELF_GUARD_ON = 1260000000,
  REVENT_SELF_GUARD_OFF = 1260000001,
  REvent_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  REvent_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool REvent_IsValid(int value);
constexpr REvent REvent_MIN = REVENT_NONE;
constexpr REvent REvent_MAX = REVENT_SELF_GUARD_OFF;
constexpr int REvent_ARRAYSIZE = REvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* REvent_descriptor();
template<typename T>
inline const std::string& REvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, REvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function REvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    REvent_descriptor(), enum_t_value);
}
inline bool REvent_Parse(
    const std::string& name, REvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<REvent>(
    REvent_descriptor(), name, value);
}
enum DualStreamType : int {
  DUAL_STREAM_TYPE_DYNAMIC = 0,
  DUAL_STREAM_TYPE_MAIN_STREAM_PRIORITY = 1,
  DUAL_STREAM_TYPE_SUB_STREAM_PRIORITY = 2,
  DualStreamType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DualStreamType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DualStreamType_IsValid(int value);
constexpr DualStreamType DualStreamType_MIN = DUAL_STREAM_TYPE_DYNAMIC;
constexpr DualStreamType DualStreamType_MAX = DUAL_STREAM_TYPE_SUB_STREAM_PRIORITY;
constexpr int DualStreamType_ARRAYSIZE = DualStreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DualStreamType_descriptor();
template<typename T>
inline const std::string& DualStreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DualStreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DualStreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DualStreamType_descriptor(), enum_t_value);
}
inline bool DualStreamType_Parse(
    const std::string& name, DualStreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DualStreamType>(
    DualStreamType_descriptor(), name, value);
}
enum Charset : int {
  KOREAN = 0,
  ENGLISH = 1,
  JAPANESE = 2,
  WESTERN = 3,
  CENTRAL_EUROPEAN = 4,
  ARABIC = 5,
  BALTIC = 6,
  CYRILLIC = 7,
  GREEK = 8,
  HEBREW = 9,
  THAI = 10,
  TURKISH = 11,
  VIETNAMESE = 12,
  CHINESE_SIMPLIFIED = 13,
  CHINESE_TRADITIONAL = 14,
  Charset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Charset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Charset_IsValid(int value);
constexpr Charset Charset_MIN = KOREAN;
constexpr Charset Charset_MAX = CHINESE_TRADITIONAL;
constexpr int Charset_ARRAYSIZE = Charset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Charset_descriptor();
template<typename T>
inline const std::string& Charset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Charset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Charset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Charset_descriptor(), enum_t_value);
}
inline bool Charset_Parse(
    const std::string& name, Charset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Charset>(
    Charset_descriptor(), name, value);
}
enum AppLanguage : int {
  APP_LANGUAGE_KOREAN = 0,
  APP_LANGUAGE_ENGLISH = 1,
  APP_LANGUAGE_JAPANESE = 2,
  APP_LANGUAGE_RUSSIAN = 3,
  APP_LANGUAGE_SPANISH = 4,
  APP_LANGUAGE_DUTCH = 5,
  AppLanguage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AppLanguage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AppLanguage_IsValid(int value);
constexpr AppLanguage AppLanguage_MIN = APP_LANGUAGE_KOREAN;
constexpr AppLanguage AppLanguage_MAX = APP_LANGUAGE_DUTCH;
constexpr int AppLanguage_ARRAYSIZE = AppLanguage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppLanguage_descriptor();
template<typename T>
inline const std::string& AppLanguage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppLanguage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppLanguage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppLanguage_descriptor(), enum_t_value);
}
inline bool AppLanguage_Parse(
    const std::string& name, AppLanguage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppLanguage>(
    AppLanguage_descriptor(), name, value);
}
enum FenConnectionType : int {
  FEN_CONNECTION_TYPE_UNKNOWN = 0,
  FEN_CONNECTION_TYPE_TCP_DIRECT_EXTERNAL = 1,
  FEN_CONNECTION_TYPE_TCP_DIRECT_INTERNAL = 2,
  FEN_CONNECTION_TYPE_UDP_HOLE_PUNCHING = 3,
  FEN_CONNECTION_TYPE_VIA_RELAY_SERVICE = 4,
  FenConnectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FenConnectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FenConnectionType_IsValid(int value);
constexpr FenConnectionType FenConnectionType_MIN = FEN_CONNECTION_TYPE_UNKNOWN;
constexpr FenConnectionType FenConnectionType_MAX = FEN_CONNECTION_TYPE_VIA_RELAY_SERVICE;
constexpr int FenConnectionType_ARRAYSIZE = FenConnectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FenConnectionType_descriptor();
template<typename T>
inline const std::string& FenConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FenConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FenConnectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FenConnectionType_descriptor(), enum_t_value);
}
inline bool FenConnectionType_Parse(
    const std::string& name, FenConnectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FenConnectionType>(
    FenConnectionType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Rp

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Rp::ImageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::ImageFormat>() {
  return ::Rp::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::Rp::AddressType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::AddressType>() {
  return ::Rp::AddressType_descriptor();
}
template <> struct is_proto_enum< ::Rp::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::DeviceType>() {
  return ::Rp::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::Rp::CameraState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::CameraState>() {
  return ::Rp::CameraState_descriptor();
}
template <> struct is_proto_enum< ::Rp::PtzFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::PtzFunction>() {
  return ::Rp::PtzFunction_descriptor();
}
template <> struct is_proto_enum< ::Rp::PtzCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::PtzCommand>() {
  return ::Rp::PtzCommand_descriptor();
}
template <> struct is_proto_enum< ::Rp::PtzCommandMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::PtzCommandMethod>() {
  return ::Rp::PtzCommandMethod_descriptor();
}
template <> struct is_proto_enum< ::Rp::OsdInfoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::OsdInfoType>() {
  return ::Rp::OsdInfoType_descriptor();
}
template <> struct is_proto_enum< ::Rp::RewindCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::RewindCommand>() {
  return ::Rp::RewindCommand_descriptor();
}
template <> struct is_proto_enum< ::Rp::FastForwardCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::FastForwardCommand>() {
  return ::Rp::FastForwardCommand_descriptor();
}
template <> struct is_proto_enum< ::Rp::PlayCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::PlayCommand>() {
  return ::Rp::PlayCommand_descriptor();
}
template <> struct is_proto_enum< ::Rp::SelfGuardCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::SelfGuardCommand>() {
  return ::Rp::SelfGuardCommand_descriptor();
}
template <> struct is_proto_enum< ::Rp::SelfGuardResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::SelfGuardResult>() {
  return ::Rp::SelfGuardResult_descriptor();
}
template <> struct is_proto_enum< ::Rp::SelfGuardStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::SelfGuardStatus>() {
  return ::Rp::SelfGuardStatus_descriptor();
}
template <> struct is_proto_enum< ::Rp::DisconnectReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::DisconnectReason>() {
  return ::Rp::DisconnectReason_descriptor();
}
template <> struct is_proto_enum< ::Rp::RequestResultSuccess> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::RequestResultSuccess>() {
  return ::Rp::RequestResultSuccess_descriptor();
}
template <> struct is_proto_enum< ::Rp::RequestResultFail> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::RequestResultFail>() {
  return ::Rp::RequestResultFail_descriptor();
}
template <> struct is_proto_enum< ::Rp::REvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::REvent>() {
  return ::Rp::REvent_descriptor();
}
template <> struct is_proto_enum< ::Rp::DualStreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::DualStreamType>() {
  return ::Rp::DualStreamType_descriptor();
}
template <> struct is_proto_enum< ::Rp::Charset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::Charset>() {
  return ::Rp::Charset_descriptor();
}
template <> struct is_proto_enum< ::Rp::AppLanguage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::AppLanguage>() {
  return ::Rp::AppLanguage_descriptor();
}
template <> struct is_proto_enum< ::Rp::FenConnectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Rp::FenConnectionType>() {
  return ::Rp::FenConnectionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_RpType_2eproto
